# Claude Code Workshop Structure - Single Progressive Project

## Overview

This workshop uses a **single codebase** that evolves through all 6 challenges. Participants work in the same `claude-code-workshop` directory throughout, building on their previous work.

## Project: claude-code-workshop

A Java microservices platform that grows from simple calculator to full API system.

### Starting State
- Basic Calculator service (has bugs) ← Challenge 1
- OrderService (messy legacy code) ← Challenge 5
- Basic auth utilities ← Challenge 4
- No .claude/rules.md yet ← Challenge 2
- No custom skills yet ← Challenge 3
- No BookService yet ← Challenge 6

### Final State (After All Challenges)
- Fixed Calculator with logging
- .claude/rules.md with team standards
- Custom java-service-generator skill
- UserService (generated by skill)
- Refactored OrderService (clean code)
- BookService (complete REST API)
- Comprehensive tests
- Security issues identified and documented

## Challenge Progression

### Challenge 1: Fix Calculator (20 min)
**Starting point:** Calculator with bugs
**What they do:** Fix percentage bug, add logging
**Tools learned:** Read, Edit, Bash
**Outcome:** Working calculator, basic workflow understanding

### Challenge 2: Add Project Rules (10 min)
**Starting point:** Calculator now works, but code needs standards
**What they do:** Create .claude/rules.md, refactor Calculator to follow rules
**Tools learned:** Project rules, refactoring with rules
**Outcome:** .claude/rules.md exists, Calculator follows standards

### Challenge 3: Generate UserService (10 min)
**Starting point:** Platform needs user management
**What they do:** Create custom skill, use it to generate UserService
**Tools learned:** Skills, custom automation
**Outcome:** java-service-generator skill exists, UserService added to platform

### Challenge 4: Security Audit (10 min)
**Starting point:** Platform has auth code with security issues
**What they do:** Use Explore sub-agent to find vulnerabilities
**Tools learned:** Sub-agents, security analysis
**Outcome:** Security issues documented, understand sub-agent power

### Challenge 5: Refactor OrderService (15 min)
**Starting point:** Platform has messy legacy OrderService
**What they do:** Multi-session refactoring with /remember
**Tools learned:** Context management, /remember, session resuming
**Outcome:** Clean OrderService, refactoring documented

### Challenge 6: Build BookService (20 min)
**Starting point:** Platform needs book management API
**What they do:** Build complete REST API using all learned skills
**Tools learned:** Integration of all concepts
**Outcome:** Complete BookService with tests, mastery demonstration

## Setup Flow

### Pre-Workshop (Participants do at home)
1. Install Claude Code CLI
2. Set up API key
3. Clone/download starter project
4. Verify setup with `mvn compile`

### Workshop Day
- Everyone starts in same directory: `claude-code-workshop/`
- Stays in same directory for all 6 challenges
- Each challenge builds on previous work
- No need to switch projects or download new code

## Directory Structure

```
claude-code-workshop/
├── src/
│   ├── main/java/com/workshop/
│   │   ├── calculator/
│   │   │   ├── Calculator.java (has bug - Challenge 1)
│   │   │   ├── CalculatorService.java (needs logging - Challenge 1)
│   │   │   └── CalculatorController.java
│   │   ├── order/
│   │   │   ├── OrderService.java (messy 300 lines - Challenge 5)
│   │   │   └── Order.java
│   │   ├── auth/
│   │   │   ├── AuthService.java (has security issues - Challenge 4)
│   │   │   ├── TokenService.java (has issues - Challenge 4)
│   │   │   └── JwtUtil.java
│   │   ├── user/
│   │   │   └── (empty - Challenge 3 will add UserService)
│   │   ├── book/
│   │   │   └── (empty - Challenge 6 will add BookService)
│   │   └── config/
│   │       └── AppConfig.java
│   └── test/java/com/workshop/
│       ├── calculator/
│       │   └── CalculatorTest.java (has failing tests - Challenge 1)
│       └── (other test directories)
├── .claude/
│   └── (empty - Challenge 2 will add rules.md)
├── pom.xml
├── README.md
└── PROGRESS.md (track what's been done)
```

## Benefits of Single Project Approach

### For Participants
- ✅ Set up once, use throughout
- ✅ Stay in familiar codebase
- ✅ See realistic project evolution
- ✅ Build on own previous work
- ✅ No context switching between projects
- ✅ Clear sense of progress

### For Facilitators
- ✅ Easier setup verification
- ✅ Easier troubleshooting (everyone on same code)
- ✅ Can demonstrate on same project
- ✅ Less download/setup time
- ✅ More workshop time for learning

### For Workshop Flow
- ✅ Realistic simulation of real development
- ✅ Natural progression of complexity
- ✅ Each challenge builds on previous learning
- ✅ Final project showcases all work
- ✅ Participants leave with complete working system

## Key Design Decisions

1. **All bugs/issues present from start:** No need to introduce new problems, they're already there
2. **Empty directories for future work:** Shows where new features will go
3. **PROGRESS.md file:** Participants track their journey
4. **Realistic mix:** Some old code (OrderService), some new (BookService)
5. **Security issues already present:** Just need to find them (Challenge 4)

## Success Metrics

After all challenges, participants have:
- One complete, working codebase
- Fixed bugs and added features
- Established coding standards
- Created custom automation
- Performed security audit
- Refactored legacy code
- Built new REST API
- Comprehensive test coverage

All in a single, cohesive project they can reference later.
